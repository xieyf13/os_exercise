# lec14 课堂练习第二题报告

2013011356 董豪宇

2013011302 李奕昕

## 用户进程的启动、运行、就绪、等待、退出

从调用轨迹上来说, 在用户态的程序, 要启动, 就绪, 等待, 退出, 都是通过调用user库当中的相应函数, 而这些函数又使用相应的系统调用通知内核, 内核再通过相应的函数来实现相应的功能, 整个过程大同小异, 有关资源的问题, 会在之后讨论, 因此不再赘述. 

只是需要注意的是, 在ucore中, 进程的状态除了比较特殊的`PROC_UINIT`态之外, 就是`PROC_ZOMBIE`(僵尸态), `PROC_RUNABLE`(就绪态), `PROC_SLEEPING`(挂起态). 

`weakup_proc`使进程进入`PROC_RUNNABLE`态, `do_wait`在该进程等待的孩子不是`PROC_ZOMBIE`态时会使进程进入`PROC_WAITING`态, 而进程退出会使进程进入`PROC_ZOMBIE`态. 

## 用户进程的管理与简单调度

在本次所用到的ucore当中, 进程的自动切换依赖于时钟中断, 时钟中断每达到一百次, 就让当前的进程变为可被置换的, 并在`trap`函数当中判断当前进程是否需要被调度, 如果需要, 就调用`schedule`函数. 例如在退出和等待时. 另外, 进程在退出和等待时, 也会有`schdule`的调用. 

## 用户进程的上下文切换过程

用户进程的上下文过程主要是通过`switch_to`函数进行. 

在这里用比较复杂的用户程序第一次启动的过程来作为例子说明. 

第一个用户态的线程, 是由`init_main`线程(即ucore中的第二个线程)创建的, 通过`kernel_thread`为`user_main`分配了一个新线程所需要的资源, 包括中断帧的简建立, 进程入口的设置, 以及栈空间分配, 页表拷贝, id申请, 将新创建的`proc_struct`加入链表当中, 之后就唤起进程, 等待被调度. 

`user_main`被调度之后, 就会执行`KERNEL_EXECVE(exit);`, 这是一个宏, 效果是指定一个叫做exit的应用程序进行执行, 最终会调用函数`kernel_execve(name, binary, (size_t)(size));`, 其中`name`就是该应用进程的名字, `binary`是应用程序的开始地址, `size`是应用程序的大小. 

`kernel_execve`会通过系统调用, 最终调用函数`do_execve`进行实际的执行, 在这部分中做得事情包括cr3寄存器的重新赋值, 内存管理引用计数更改, 名字设置, 以及调用函数`load_icode`.

`load_icode`的功能, 包括创建新的内存管理, 进行内存映射, 为应用程序申请页面, 并拷贝代码段和初始与未初始数据段, 为进程创建可供使用的用户态堆栈, 最后修改中断帧, 在其中设置代码段入口. 

上述工作全部结束之后, 进程等待被调度即可, 至于被调度之后如何开始执行, 具体过程依赖于`proc`中的中断帧和上下文, 以及异常返回机制. 进程被选择调度之后, 会通过`proc_run`实际唤醒, 在其中会执行汇编函数`switch_to`, 在函数的最后, 会把被调度程序中`context.eip`压入到栈中然后返回, 这时, 程序就会跳到汇编函数`forkrets`, 这个函数会将`proc`中保存的`trapframe`取出作为参数, 然后跳到__trapret进行返回, 在返回过程当中, 自然就跳到了进程的代码入口(会取trapframe中的eip)

## 用户进程的特权级切换过程

特权级的切换对操作系统来说相对简单, 由于特权级切换只有可能在异常返回时才有需要选择的情况(进入异常时, 特权级一定是变为0, 而退出异常时, 特权级就有可能是0或是3), 只要在进程对应的trapframe当中对段寄存器进行合适的设置, 硬件就会完成相应设置. 

从调用角度来说, 在用户态, 应用程序调用fork等函数时还处于用户态, 但这些函数使用系统调用之后就进入了核心态. 

## 用户进程的创建过程并完成资源占用

这部分主要在`do_fork`当中完成, 所做的事情包括`alloc_proc`, 为PCB分配空间, `setup_kstack`, `copy_mm`, `copy_thread`, `get_pid`, 分别是为进程分配内核栈空间, 拷贝或分享使用空间, 为进程设置内核栈顶和trapframe并设置入口, 获取进程号. 

## 用户进程的退出过程并完成资源回收

少部分在`do_exit`, 在这部分会将cr3寄存器的值设置为boot_cr3, 因为此时在内核中活动, 每个进程看到的内核空间相同, 因此不会出现问题, 然后将该进程的mm的ref减一, 如果引用数为零, 则释放mm, 这一步相当于释放空间. 另一部分在`do_wait`当中, PCB的所占用的资源会由其父进程(也有可能是initproc)来负责释放掉. 